<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schmitt Odyss√©e</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }

        .game-area {
            flex: 1;
            display: flex;
            gap: 20px;
            min-height: 0;
        }

        .board-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.3em;
        }

        .player-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .player-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .player-item:not(.active) {
            background: #f0f0f0;
        }

        .player-name {
            font-weight: bold;
        }

        .player-info {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .dice-result {
            text-align: center;
            font-size: 3em;
            color: #667eea;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .setup-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .setup-panel {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .setup-panel h2 {
            color: #667eea;
            margin-bottom: 25px;
            text-align: center;
            font-size: 2em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: bold;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .player-inputs {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .player-input-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .player-input-item input {
            flex: 1;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
        }

        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                flex-direction: row;
            }

            .panel {
                flex: 1;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                flex-direction: column;
            }

            .header h1 {
                font-size: 1.8em;
            }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
            text-align: center;
        }

        .modal-content p {
            font-size: 1.2em;
            line-height: 1.6;
            color: #333;
            margin-bottom: 15px;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        .tile-effect-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 20px;
        }

        .player-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .player-selector-item {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .player-selector-item:hover {
            border-color: #667eea;
            background: #f0f0f0;
        }

        .player-selector-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white;
            padding: 30px 50px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 2500;
            transition: transform 0.3s ease;
            text-align: center;
            font-size: 1.5em;
            color: #667eea;
            font-weight: bold;
        }

        .notification.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .input-group {
            margin: 20px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: particleFall 2s ease-out forwards;
        }

        @keyframes particleFall {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(100px) scale(0.5);
            }
        }

        .history-panel {
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .history-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }

        .victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            animation: fadeIn 0.5s ease;
        }

        .victory-screen.show {
            display: flex;
        }

        .victory-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 60px;
            border-radius: 30px;
            text-align: center;
            color: white;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease;
        }

        .victory-content h1 {
            font-size: 4em;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        .victory-content .winner-name {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .manual-mode-toggle {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            color: white;
            font-weight: bold;
        }

        .manual-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .manual-mode-toggle.active {
            background: linear-gradient(135deg, #f39c12 0%, #e74c3c 100%);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .manual-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
            min-width: 300px;
        }

        .manual-controls.show {
            display: block;
        }

        .manual-controls h3 {
            margin: 0 0 15px 0;
            color: #667eea;
            font-size: 1.2em;
        }

        .manual-controls .player-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .manual-controls .player-select button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            font-weight: bold;
        }

        .manual-controls .player-select button.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .manual-controls .position-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .manual-controls input[type="number"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .manual-controls .direction-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .manual-controls .direction-toggle button {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .manual-controls .direction-toggle button.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
    </style>
</head>

<body>
    <div class="container">
        <button class="sound-toggle" id="soundToggle">üîä</button>
        <button class="manual-mode-toggle" id="manualModeToggle">üéØ Mode Manuel</button>

        <div class="header">
            <h1>üèõÔ∏è Schmitt Odyss√©e üèõÔ∏è</h1>
            <p>La victoire n'est qu'ivresse du jeu !</p>
        </div>

        <div class="game-area">
            <div class="board-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h2>Joueurs</h2>
                    <div class="player-list" id="playerList"></div>
                </div>

                <div class="panel">
                    <h2>Contr√¥les</h2>
                    <div class="dice-result" id="diceResult">üé≤</div>
                    <div class="controls">
                        <button class="btn btn-primary" id="rollDiceBtn">Lancer le d√©</button>
                        <button class="btn btn-primary" id="forceUnlockBtn"
                            style="background: #f39c12; display: none;">üîì D√©bloquer</button>
                        <button class="btn btn-primary" id="resetBtn" style="background: #e74c3c;">Nouvelle
                            partie</button>
                    </div>
                </div>

                <div class="panel">
                    <h2>Historique</h2>
                    <div class="history-panel" id="historyPanel"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="setup-screen" id="setupScreen">
        <div class="setup-panel">
            <h2>Configuration de la partie</h2>
            <div class="form-group">
                <label>Nombre de joueurs (2-10)</label>
                <input type="number" id="playerCount" min="2" max="10" value="4">
            </div>
            <div class="player-inputs" id="playerInputs"></div>
            <button class="btn btn-primary" id="startGameBtn" style="width: 100%;">Commencer la partie</button>
        </div>
    </div>

    <div class="modal" id="effectModal">
        <div class="modal-content">
            <div class="tile-effect-icon" id="effectIcon"></div>
            <h2 id="effectTitle"></h2>
            <p id="effectDescription"></p>
            <div id="effectInteraction"></div>
            <div class="modal-actions">
                <button class="btn btn-primary" id="effectOkBtn">OK</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <div class="manual-controls" id="manualControls">
        <h3>üéØ D√©placement Manuel</h3>
        <p style="font-size: 0.9em; margin-bottom: 15px; color: #666;">S√©lectionnez un joueur et d√©placez-le</p>

        <div class="player-select" id="manualPlayerSelect"></div>

        <div class="position-input">
            <label style="font-weight: bold;">Position:</label>
            <input type="number" id="manualPosition" min="0" max="22" value="0">
        </div>

        <div class="direction-toggle">
            <button id="directionForward" class="selected">‚û°Ô∏è Aller</button>
            <button id="directionBackward">‚¨ÖÔ∏è Retour</button>
        </div>

        <button class="btn btn-primary" id="applyManualMove" style="width: 100%;">Appliquer</button>
    </div>

    <div class="victory-screen" id="victoryScreen">
        <div class="victory-content">
            <h1>üéâ VICTOIRE ! üéâ</h1>
            <div class="winner-name" id="winnerName"></div>
            <div class="stats-grid" id="statsGrid"></div>
            <button class="btn btn-primary" onclick="location.reload()"
                style="margin-top: 20px; font-size: 1.2em;">Nouvelle partie</button>
        </div>
    </div>

    <script>
        // Configuration du jeu
        const BOARD_SIZE = 23; // Nombre de cases (0 √† 22)
        const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#00bcd4'];

        // Types de cases
        const TILE_TYPES = {
            START: 'start',
            DRINK_2: 'drink_2',
            DRINK_3: 'drink_3',
            DRINK_4: 'drink_4',
            DISTRIBUTE_2: 'distribute_2',
            DISTRIBUTE_3: 'distribute_3',
            DISTRIBUTE_4: 'distribute_4',
            EVERYONE_DRINKS: 'everyone_drinks',
            MOVE_FORWARD_2: 'move_forward_2',
            CHICKEN: 'chicken',
            COPY: 'copy',
            RULE: 'rule',
            SCHMITT_CALL: 'schmitt_call',
            TEMPLE: 'temple',
            POWER: 'power',
            EMPTY: 'empty'
        };

        // Configuration du plateau (d√©finition de chaque case selon le JSON)
        const BOARD_CONFIG = [
            { type: TILE_TYPES.START, icon: 'üèÅ', name: 'START' },                          // 0
            { type: TILE_TYPES.EVERYONE_DRINKS, icon: 'üçª', name: 'TOURN√âE G√âN√âRALE' },     // 1
            { type: TILE_TYPES.MOVE_FORWARD_2, icon: '‚¨ÜÔ∏è', name: 'AVANCEZ +2' },            // 2
            { type: TILE_TYPES.DRINK_2, icon: 'üç∫', name: 'BUVEZ 2' },                      // 3
            { type: TILE_TYPES.TEMPLE, icon: 'üèõÔ∏è', name: 'FAVEUR DES DIEUX' },             // 4
            { type: TILE_TYPES.CHICKEN, icon: 'üêî', name: 'PETIT POULET' },                 // 5
            { type: TILE_TYPES.DISTRIBUTE_2, icon: 'üéÅ', name: 'DISTRIBUEZ 2' },            // 6
            { type: TILE_TYPES.DRINK_3, icon: 'üç∫', name: 'BUVEZ 3' },                      // 7
            { type: TILE_TYPES.COPY, icon: 'üêë', name: 'MOUTON' },                          // 8
            { type: TILE_TYPES.MOVE_FORWARD_2, icon: '‚¨ÜÔ∏è', name: 'AVANCEZ +2' },            // 9
            { type: TILE_TYPES.DISTRIBUTE_4, icon: 'üéÅ', name: 'DISTRIBUEZ 4' },            // 10
            { type: TILE_TYPES.SCHMITT_CALL, icon: '‚ö°', name: 'SCHMITT !!!' },             // 11
            { type: TILE_TYPES.RULE, icon: 'üìú', name: 'CR√âEZ R√àGLE' },                     // 12
            { type: TILE_TYPES.MOVE_FORWARD_2, icon: '‚¨ÜÔ∏è', name: 'AVANCEZ +2' },            // 13
            { type: TILE_TYPES.COPY, icon: 'üêë', name: 'MOUTON' },                          // 14
            { type: TILE_TYPES.DRINK_4, icon: 'üç∫', name: 'BUVEZ 4' },                      // 15
            { type: TILE_TYPES.DISTRIBUTE_3, icon: 'üéÅ', name: 'DISTRIBUEZ 3' },            // 16
            { type: TILE_TYPES.CHICKEN, icon: 'üêî', name: 'PETIT POULET' },                 // 17
            { type: TILE_TYPES.TEMPLE, icon: 'üèõÔ∏è', name: 'FAVEUR DES DIEUX' },             // 18
            { type: TILE_TYPES.DISTRIBUTE_2, icon: 'üéÅ', name: 'DISTRIBUEZ 2' },            // 19
            { type: TILE_TYPES.MOVE_FORWARD_2, icon: '‚¨ÜÔ∏è', name: 'AVANCEZ +2' },            // 20
            { type: TILE_TYPES.EVERYONE_DRINKS, icon: 'üçª', name: 'TOURN√âE G√âN√âRALE' },     // 21
            { type: TILE_TYPES.POWER, icon: 'üëë', name: 'POUVOIR SCHMITT' }                 // 22 (FINISH)
        ];

        // √âtat du jeu
        let gameState = {
            players: [],
            currentPlayerIndex: 0,
            canvas: null,
            ctx: null,
            isRolling: false,
            lastDiceValue: null,
            chickenPlayer: null,
            customRules: [],
            waitingForEffect: false,
            history: [],
            soundEnabled: true,
            startTime: null,
            totalMoves: 0,
            manualMode: false,
            selectedPlayerForManual: null
        };

        // Sons (utilisation de l'API Web Audio)
        const sounds = {
            dice: () => playBeep(300, 0.1),
            move: () => playBeep(400, 0.05),
            drink: () => playBeep(200, 0.15),
            win: () => playMelody([523, 659, 784, 1047], 0.2),
            effect: () => playBeep(500, 0.1),
            temple: () => playMelody([392, 523, 659], 0.15)
        };

        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playBeep(frequency, duration) {
            if (!gameState.soundEnabled || !audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playMelody(notes, duration) {
            if (!gameState.soundEnabled || !audioContext) return;

            notes.forEach((note, index) => {
                setTimeout(() => playBeep(note, duration), index * duration * 1000);
            });
        }

        class Player {
            constructor(name, color, index) {
                this.name = name;
                this.color = color;
                this.position = 0;
                this.index = index;
                this.hasSchmittPower = false;
                this.isReturning = false;
                this.drinks = 0;
                this.hasAthenaShield = false;
            }
        }

        function init() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            document.getElementById('playerCount').addEventListener('change', generatePlayerInputs);
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('rollDiceBtn').addEventListener('click', rollDice);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('effectOkBtn').addEventListener('click', closeEffectModal);
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
            document.getElementById('forceUnlockBtn').addEventListener('click', forceUnlock);
            document.getElementById('manualModeToggle').addEventListener('click', toggleManualMode);
            document.getElementById('directionForward').addEventListener('click', () => selectDirection(false));
            document.getElementById('directionBackward').addEventListener('click', () => selectDirection(true));
            document.getElementById('applyManualMove').addEventListener('click', applyManualMove);

            // Show unlock button if dice is stuck
            setInterval(() => {
                if (gameState.isRolling && gameState.players.length > 0) {
                    document.getElementById('forceUnlockBtn').style.display = 'block';
                } else {
                    document.getElementById('forceUnlockBtn').style.display = 'none';
                }
            }, 1000);

            // Initialize audio on first user interaction
            document.body.addEventListener('click', () => {
                initAudio();
            }, { once: true });

            generatePlayerInputs();
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundToggle').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
            if (gameState.soundEnabled) {
                initAudio();
                playBeep(400, 0.1);
            }
        }

        function forceUnlock() {
            console.log('FORCE UNLOCK - Resetting all states');
            gameState.isRolling = false;
            gameState.waitingForEffect = false;
            document.getElementById('rollDiceBtn').disabled = false;
            document.getElementById('forceUnlockBtn').style.display = 'none';

            // Close any open modal
            closeEffectModal();

            // Move to next player since current player already played
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            updatePlayerList();

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            showNotification(`‚ö†Ô∏è Jeu d√©bloqu√© ! Au tour de ${currentPlayer.name}`);
        }

        function toggleManualMode() {
            gameState.manualMode = !gameState.manualMode;
            const btn = document.getElementById('manualModeToggle');
            const controls = document.getElementById('manualControls');

            if (gameState.manualMode) {
                btn.classList.add('active');
                btn.textContent = 'üéØ Mode Manuel (ON)';
                controls.classList.add('show');
                updateManualPlayerSelect();
                showNotification('Mode manuel activ√© - Cliquez sur un joueur');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üéØ Mode Manuel';
                controls.classList.remove('show');
                gameState.selectedPlayerForManual = null;
                showNotification('Mode manuel d√©sactiv√©');
            }
        }

        function updateManualPlayerSelect() {
            const container = document.getElementById('manualPlayerSelect');
            container.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const btn = document.createElement('button');
                btn.textContent = player.name;
                btn.style.borderColor = player.color;
                btn.onclick = () => selectPlayerForManual(player, btn);

                if (gameState.selectedPlayerForManual === player) {
                    btn.classList.add('selected');
                    document.getElementById('manualPosition').value = player.position;
                }

                container.appendChild(btn);
            });
        }

        function selectPlayerForManual(player, btn) {
            gameState.selectedPlayerForManual = player;

            // Update UI
            document.querySelectorAll('#manualPlayerSelect button').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');

            // Set current position
            document.getElementById('manualPosition').value = player.position;

            // Set direction
            const forwardBtn = document.getElementById('directionForward');
            const backwardBtn = document.getElementById('directionBackward');
            if (player.isReturning) {
                forwardBtn.classList.remove('selected');
                backwardBtn.classList.add('selected');
            } else {
                forwardBtn.classList.add('selected');
                backwardBtn.classList.remove('selected');
            }
        }

        function selectDirection(isBackward) {
            const forwardBtn = document.getElementById('directionForward');
            const backwardBtn = document.getElementById('directionBackward');

            if (isBackward) {
                forwardBtn.classList.remove('selected');
                backwardBtn.classList.add('selected');
            } else {
                forwardBtn.classList.add('selected');
                backwardBtn.classList.remove('selected');
            }
        }

        function applyManualMove() {
            if (!gameState.selectedPlayerForManual) {
                showNotification('‚ö†Ô∏è S√©lectionnez un joueur !');
                return;
            }

            const player = gameState.selectedPlayerForManual;
            const newPosition = parseInt(document.getElementById('manualPosition').value);
            const isBackward = document.getElementById('directionBackward').classList.contains('selected');

            if (newPosition < 0 || newPosition > BOARD_SIZE - 1) {
                showNotification('‚ö†Ô∏è Position invalide (0-22) !');
                return;
            }

            player.position = newPosition;
            player.isReturning = isBackward;

            drawBoard();
            updatePlayerList();
            addToHistory(`üéØ ${player.name} d√©plac√© manuellement √† la case ${newPosition} (${isBackward ? 'retour' : 'aller'})`);
            showNotification(`${player.name} ‚Üí Case ${newPosition}`);

            sounds.effect();
        }

        function resizeCanvas() {
            const container = gameState.canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, container.clientHeight - 40);
            gameState.canvas.width = size;
            gameState.canvas.height = size;

            if (gameState.players.length > 0) {
                drawBoard();
            }
        }

        function generatePlayerInputs() {
            const count = parseInt(document.getElementById('playerCount').value);
            const container = document.getElementById('playerInputs');
            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'player-input-item';
                div.innerHTML = `
                    <input type="text" placeholder="Joueur ${i + 1}" value="Joueur ${i + 1}" data-player-index="${i}">
                    <input type="color" class="color-picker" value="${COLORS[i % COLORS.length]}" data-player-index="${i}">
                `;
                container.appendChild(div);
            }
        }

        function startGame() {
            const inputs = document.querySelectorAll('#playerInputs input[type="text"]');
            const colorInputs = document.querySelectorAll('#playerInputs input[type="color"]');

            gameState.players = [];
            inputs.forEach((input, index) => {
                const name = input.value.trim() || `Joueur ${index + 1}`;
                const color = colorInputs[index].value;
                gameState.players.push(new Player(name, color, index));
            });

            gameState.currentPlayerIndex = 0;
            gameState.startTime = Date.now();
            gameState.totalMoves = 0;
            gameState.history = [];
            document.getElementById('setupScreen').style.display = 'none';

            drawBoard();
            updatePlayerList();
            updateHistory();
            showNotification(`${gameState.players[0].name} commence !`);
            sounds.effect();
            createParticles(gameState.canvas.width / 2, gameState.canvas.height / 2, 'üéÆ');
        }

        function addToHistory(message) {
            gameState.history.unshift(message);
            if (gameState.history.length > 20) {
                gameState.history.pop();
            }
            updateHistory();
        }

        function updateHistory() {
            const panel = document.getElementById('historyPanel');
            panel.innerHTML = '';

            gameState.history.forEach(msg => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.textContent = msg;
                panel.appendChild(div);
            });
        }

        function resetGame() {
            // Reset game state
            gameState.players = [];
            gameState.currentPlayerIndex = 0;
            gameState.lastDiceValue = null;
            gameState.chickenPlayer = null;
            gameState.customRules = [];
            gameState.waitingForEffect = false;
            gameState.history = [];
            gameState.startTime = null;
            gameState.totalMoves = 0;
            gameState.isRolling = false;

            // Reset UI
            document.getElementById('diceResult').textContent = 'üé≤';
            document.getElementById('rollDiceBtn').disabled = false;
            document.getElementById('playerList').innerHTML = '';
            document.getElementById('historyPanel').innerHTML = '';

            // Clear canvas
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Show setup screen
            document.getElementById('setupScreen').style.display = 'flex';

            // Regenerate player inputs
            generatePlayerInputs();
        }

        function drawBoard() {
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width * 0.35;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 1.5);
            bgGradient.addColorStop(0, '#f8f9fa');
            bgGradient.addColorStop(1, '#e9ecef');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < BOARD_SIZE; i++) {
                const angle = (i / BOARD_SIZE) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                ctx.beginPath();
                ctx.arc(x, y, 18, 0, Math.PI * 2);

                const tile = BOARD_CONFIG[i];
                if (tile.type === TILE_TYPES.START) {
                    ctx.fillStyle = '#2ecc71';
                } else if (tile.type === TILE_TYPES.POWER) {
                    ctx.fillStyle = '#f39c12';
                } else if (tile.type === TILE_TYPES.TEMPLE) {
                    ctx.fillStyle = '#9b59b6';
                } else {
                    ctx.fillStyle = '#fff';
                }
                ctx.fill();

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw icon
                if (tile.icon) {
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tile.icon, x, y);
                }
            }

            ctx.fillStyle = '#667eea';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('SCHMITT', centerX, centerY - 10);
            ctx.font = '16px Arial';
            ctx.fillText('ODYSS√âE', centerX, centerY + 15);

            drawPlayers();
        }

        function drawPlayers() {
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width * 0.35;

            gameState.players.forEach((player, playerIndex) => {
                // Calculate visual position based on direction
                let visualPosition = player.position;

                const angle = (visualPosition / BOARD_SIZE) * Math.PI * 2 - Math.PI / 2;
                const baseX = centerX + Math.cos(angle) * radius;
                const baseY = centerY + Math.sin(angle) * radius;

                // Offset for multiple players on same case
                const playersOnCase = gameState.players.filter(p => p.position === player.position);
                const offset = playersOnCase.indexOf(player);
                const totalOnCase = playersOnCase.length;
                const offsetAngle = (offset - (totalOnCase - 1) / 2) * 0.3;

                const x = baseX + Math.cos(angle + offsetAngle) * 25;
                const y = baseY + Math.sin(angle + offsetAngle) * 25;

                // Draw player pawn
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = playerIndex === gameState.currentPlayerIndex ? '#fff' : '#333';
                ctx.lineWidth = playerIndex === gameState.currentPlayerIndex ? 3 : 2;
                ctx.stroke();

                // Draw power indicator
                if (player.hasSchmittPower) {
                    ctx.fillStyle = '#f39c12';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëë', x, y - 20);
                }

                if (gameState.chickenPlayer === player) {
                    ctx.fillText('üêî', x, y + 20);
                }

                // Draw arrow if returning
                if (player.isReturning) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('‚¨ÖÔ∏è', x + 15, y - 15);
                }
            });
        }

        function rollDice() {
            console.log('rollDice called - isRolling:', gameState.isRolling, 'waitingForEffect:', gameState.waitingForEffect);

            if (gameState.isRolling || gameState.waitingForEffect) {
                console.log('Dice roll blocked');
                return;
            }

            gameState.isRolling = true;
            document.getElementById('rollDiceBtn').disabled = true;
            sounds.dice();

            let count = 0;
            const interval = setInterval(() => {
                const randomValue = Math.floor(Math.random() * 6) + 1;
                document.getElementById('diceResult').textContent = randomValue;
                count++;

                if (count > 15) {
                    clearInterval(interval);
                    const finalValue = Math.floor(Math.random() * 6) + 1;
                    document.getElementById('diceResult').textContent = finalValue;
                    gameState.lastDiceValue = finalValue;
                    gameState.totalMoves++;

                    sounds.effect();
                    addToHistory(`üé≤ ${gameState.players[gameState.currentPlayerIndex].name} a fait ${finalValue}`);

                    // Check chicken effect
                    if (gameState.chickenPlayer && (finalValue === 3 || finalValue === 6)) {
                        const chickenIndex = gameState.players.indexOf(gameState.chickenPlayer);
                        if (chickenIndex !== gameState.currentPlayerIndex) {
                            gameState.chickenPlayer.drinks += 1;
                            showNotification(`üêî ${gameState.chickenPlayer.name} boit 1 gorg√©e !`);
                            sounds.drink();
                            addToHistory(`üêî ${gameState.chickenPlayer.name} boit (Poulet)`);
                        }
                    }

                    setTimeout(() => {
                        movePlayer(finalValue);
                    }, 500);
                }
            }, 100);
        }

        function movePlayer(steps) {
            const player = gameState.players[gameState.currentPlayerIndex];
            let step = 0;

            console.log('movePlayer started - player:', player.name, 'steps:', steps, 'current position:', player.position, 'isReturning:', player.isReturning);

            const moveInterval = setInterval(() => {
                if (step < steps) {
                    // Move forward or backward depending on direction
                    if (player.isReturning) {
                        player.position--;

                        // If we go below 0, bounce back forward
                        if (player.position < 0) {
                            player.position = Math.abs(player.position);
                            // Stay in returning mode
                        }
                    } else {
                        player.position++;

                        // If we go beyond FINISH, bounce back
                        if (player.position > BOARD_SIZE - 1) {
                            const overflow = player.position - (BOARD_SIZE - 1);
                            player.position = (BOARD_SIZE - 1) - overflow;
                            // Don't change returning status yet - only when landing exactly on FINISH
                        }
                    }

                    sounds.move();

                    console.log('Moving... step:', step + 1, 'position:', player.position, 'direction:', player.isReturning ? 'backward' : 'forward');

                    step++;
                    drawBoard();
                } else {
                    clearInterval(moveInterval);
                    console.log('Movement complete - final position:', player.position);

                    // Check if landed EXACTLY on FINISH (case 22) going FORWARD
                    if (!player.isReturning && player.position === BOARD_SIZE - 1 && !player.hasSchmittPower) {
                        player.hasSchmittPower = true;
                        player.isReturning = true;
                        showNotification(`${player.name} a le Pouvoir du Schmitt ! üëë Tout le monde repart en arri√®re !`);
                        sounds.win();
                        createParticles(gameState.canvas.width / 2, gameState.canvas.height / 2, 'üëë');
                        addToHistory(`üëë ${player.name} obtient le Pouvoir du Schmitt !`);

                        // ALL players now go backwards
                        gameState.players.forEach(p => {
                            p.isReturning = true;
                        });
                    }

                    // Check victory: if returning and landed EXACTLY on START (position 0)
                    if (player.isReturning && player.position === 0) {
                        console.log('Victory condition met - reached START exactly!');
                        showVictory(player);
                        return;
                    }

                    // Apply effect after movement is complete
                    setTimeout(() => {
                        applyTileEffect();
                    }, 200);
                }
            }, 300);
        }

        function showVictory(player) {
            sounds.win();
            const duration = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;

            document.getElementById('winnerName').textContent = player.name;

            const stats = `
                <div class="stat-card">
                    <div class="label">Dur√©e de la partie</div>
                    <div class="value">${minutes}:${seconds.toString().padStart(2, '0')}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Total de mouvements</div>
                    <div class="value">${gameState.totalMoves}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Gorg√©es totales</div>
                    <div class="value">${gameState.players.reduce((sum, p) => sum + p.drinks, 0)}</div>
                </div>
            `;

            document.getElementById('statsGrid').innerHTML = stats;
            document.getElementById('victoryScreen').classList.add('show');

            // Fireworks effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticles(
                        Math.random() * window.innerWidth,
                        Math.random() * window.innerHeight / 2,
                        ['üéâ', 'üéä', '‚≠ê', '‚ú®'][Math.floor(Math.random() * 4)]
                    );
                }, i * 100);
            }
        }

        function createParticles(x, y, emoji) {
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = emoji;
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.fontSize = (Math.random() * 20 + 20) + 'px';
                document.body.appendChild(particle);

                setTimeout(() => particle.remove(), 2000);
            }
        }

        function applyTileEffect() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const tile = BOARD_CONFIG[player.position];

            console.log('applyTileEffect - player:', player.name, 'position:', player.position, 'tile:', tile?.name);

            if (!tile || tile.type === TILE_TYPES.START || tile.type === TILE_TYPES.POWER) {
                // No effect or already handled, go to next player
                console.log('No effect, going to next player');
                nextPlayer();
                return;
            }

            gameState.waitingForEffect = true;
            console.log('Applying effect:', tile.type);

            switch (tile.type) {
                case TILE_TYPES.DRINK_2:
                case TILE_TYPES.DRINK_3:
                case TILE_TYPES.DRINK_4:
                    handleDrinkEffect(tile.type);
                    break;
                case TILE_TYPES.DISTRIBUTE_2:
                case TILE_TYPES.DISTRIBUTE_3:
                case TILE_TYPES.DISTRIBUTE_4:
                    handleDistributeEffect(tile.type);
                    break;
                case TILE_TYPES.EVERYONE_DRINKS:
                    handleEveryoneDrinks();
                    break;
                case TILE_TYPES.MOVE_FORWARD_2:
                    handleMoveForward();
                    break;
                case TILE_TYPES.CHICKEN:
                    handleChicken();
                    break;
                case TILE_TYPES.COPY:
                    handleCopy();
                    break;
                case TILE_TYPES.RULE:
                    handleRule();
                    break;
                case TILE_TYPES.SCHMITT_CALL:
                    handleSchmittCall();
                    break;
                case TILE_TYPES.TEMPLE:
                    handleTemple();
                    break;
                default:
                    console.log('Unknown tile type, going to next player');
                    nextPlayer();
            }
        }

        function handleDrinkEffect(type) {
            const drinks = type === TILE_TYPES.DRINK_2 ? 2 : (type === TILE_TYPES.DRINK_3 ? 3 : 4);
            const player = gameState.players[gameState.currentPlayerIndex];
            player.drinks += drinks;
            sounds.drink();
            addToHistory(`üç∫ ${player.name} boit ${drinks} gorg√©es`);
            updatePlayerList();

            showEffect('üç∫', 'Buvez !', `${player.name} boit ${drinks} gorg√©es de liquide !`, () => {
                nextPlayer();
            });
        }

        function handleDistributeEffect(type) {
            const drinks = type === TILE_TYPES.DISTRIBUTE_2 ? 2 : (type === TILE_TYPES.DISTRIBUTE_3 ? 3 : 4);
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.effect();

            showEffect('üéÅ', 'Distribuez !', `${player.name}, distribuez ${drinks} gorg√©es √† d'autres joueurs.`, () => {
                showPlayerSelector(drinks, (selectedPlayers) => {
                    selectedPlayers.forEach(p => {
                        p.drinks += 1;
                        sounds.drink();
                    });
                    const names = selectedPlayers.map(p => p.name).join(', ');
                    showNotification(`${names} boivent !`);
                    addToHistory(`üéÅ ${player.name} distribue √† ${names}`);
                    updatePlayerList();
                    nextPlayer();
                });
            });
        }

        function handleEveryoneDrinks() {
            gameState.players.forEach(p => p.drinks += 1);
            sounds.drink();
            addToHistory(`üçª Tourn√©e g√©n√©rale !`);
            updatePlayerList();
            showEffect('üçª', 'Tourn√©e g√©n√©rale !', 'Tous les joueurs re√ßoivent 1 gorg√©e !', () => {
                nextPlayer();
            });
        }

        function handleMoveForward() {
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.effect();
            showEffect('‚¨ÜÔ∏è', 'Avancez !', `${player.name} avance de 2 cases suppl√©mentaires !`, () => {
                player.position += 2;
                if (player.position >= BOARD_SIZE - 1) {
                    player.position = BOARD_SIZE - 1;
                }
                drawBoard();
                addToHistory(`‚¨ÜÔ∏è ${player.name} avance de +2 cases`);

                setTimeout(() => {
                    applyTileEffect();
                }, 500);
            });
        }

        function handleChicken() {
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.effect();

            if (gameState.chickenPlayer === player) {
                gameState.chickenPlayer = null;
                addToHistory(`üêì ${player.name} devient GROS POULET`);
                showEffect('üêì', 'GROS POULET !', `${player.name} devient le GROS POULET et distribue les gorg√©es au lieu de les boire !`, () => {
                    nextPlayer();
                });
            } else {
                gameState.chickenPlayer = player;
                addToHistory(`üêî ${player.name} devient Petit Poulet`);
                showEffect('üêî', 'Petit Poulet !', `${player.name} devient le Petit Poulet ! √Ä chaque 3 ou 6, il boit 1 gorg√©e.`, () => {
                    nextPlayer();
                });
            }
        }

        function handleCopy() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const otherPlayers = gameState.players.filter(p => p !== player);

            showEffect('üêë', 'Copiez une case !', `${player.name}, choisissez un adversaire et copiez sa case.`, () => {
                showPlayerSelector(1, (selectedPlayers) => {
                    const target = selectedPlayers[0];
                    const targetTile = BOARD_CONFIG[target.position];

                    showNotification(`${player.name} copie la case de ${target.name} !`);

                    if (targetTile.type === TILE_TYPES.COPY) {
                        const temp = player.position;
                        player.position = target.position;
                        target.position = temp;
                        showNotification(`√âchange de position !`);
                        drawBoard();
                        setTimeout(() => nextPlayer(), 1500);
                    } else {
                        setTimeout(() => {
                            applySpecificEffect(targetTile.type);
                        }, 1000);
                    }
                }, false);
            });
        }

        function handleRule() {
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.effect();

            showEffect('üìú', 'Inventez une r√®gle !', `${player.name}, inventez une r√®gle qui durera jusqu'√† la fin de la partie.`, () => {
                showRuleInput((rule) => {
                    gameState.customRules.push({ player: player.name, rule: rule });
                    showNotification(`Nouvelle r√®gle : ${rule}`);
                    addToHistory(`üìú R√®gle : ${rule}`);
                    nextPlayer();
                });
            });
        }

        function handleSchmittCall() {
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.effect();
            addToHistory(`‚ö° ${player.name} tombe sur SCHMITT !`);

            showEffect('‚ö°', 'SCHMITT !', 'Le dernier √† crier "SCHMITT !" et placer son pouce sur son front re√ßoit des gorg√©es !', () => {
                const playersOnTile = gameState.players.filter(p => p.position === player.position);
                const sipsCount = playersOnTile.length;

                // Show player selector to choose who loses
                showPlayerSelector(1, (selectedPlayers) => {
                    const loser = selectedPlayers[0];
                    loser.drinks += sipsCount;
                    sounds.drink();
                    showNotification(`${loser.name} boit ${sipsCount} gorg√©e(s) !`);
                    addToHistory(`‚ö° ${loser.name} perd au SCHMITT (${sipsCount} gorg√©es)`);
                    updatePlayerList();
                    nextPlayer();
                }, true); // Allow selecting any player including self
            });
        }

        function handleTemple() {
            const player = gameState.players[gameState.currentPlayerIndex];
            sounds.temple();

            showEffect('üèõÔ∏è', 'Faveur des Dieux !', `${player.name} lance 2 d√©s pour obtenir une faveur divine...`, () => {
                const dice1 = Math.floor(Math.random() * 6) + 1;
                const dice2 = Math.floor(Math.random() * 6) + 1;

                if (dice1 === dice2) {
                    player.drinks += 3;
                    sounds.drink();
                    showNotification(`‚ö° COL√àRE DES DIEUX ! ${player.name} boit 3 gorg√©es !`);
                    addToHistory(`üíÄ ${player.name} subit la Col√®re des Dieux`);
                    setTimeout(() => nextPlayer(), 2000);
                } else {
                    const sum = dice1 + dice2;
                    addToHistory(`üèõÔ∏è ${player.name} obtient une faveur divine (${sum})`);
                    applyGodFavor(sum);
                }
            });
        }

        function applyGodFavor(sum) {
            const player = gameState.players[gameState.currentPlayerIndex];

            const favors = {
                2: { god: 'Ath√©na', effect: 'Vous obtenez un bouclier qui renvoie une fois toutes les gorg√©es.', icon: 'üõ°Ô∏è' },
                3: { god: 'Aphrodite', effect: 'Choisissez 2 adversaires et d√©placez-les.', icon: 'üíò' },
                4: { god: 'Herm√®s', effect: '√âchangez de position avec un adversaire.', icon: 'üëü' },
                5: { god: 'Apollon', effect: 'Rejouez et distribuez des gorg√©es.', icon: '‚òÄÔ∏è' },
                6: { god: 'Ar√®s', effect: 'Tous choisissent pouce haut/bas. Ceux qui font l\'inverse boivent.', icon: '‚öîÔ∏è' },
                7: { god: 'Dionysos', effect: 'Tous boivent jusqu\'√† ce que vous arr√™tiez.', icon: 'üç∑' },
                8: { god: 'H√©pha√Østos', effect: 'Placez 2 shooters sur des cases.', icon: 'üî®' },
                9: { god: 'Pos√©idon', effect: 'Ciblez un joueur qui boit, ses voisins aussi.', icon: 'üî±' },
                10: { god: 'Jugement Dernier', effect: 'Conservez 1 d√© et relancez l\'autre.', icon: '‚öñÔ∏è' },
                11: { god: 'Jugement Dernier', effect: 'Conservez 1 d√© et relancez l\'autre.', icon: '‚öñÔ∏è' },
                12: { god: 'Col√®re Divine', effect: 'Buvez 3 gorg√©es !', icon: 'üíÄ' }
            };

            const favor = favors[sum];

            showEffect(favor.icon, favor.god, favor.effect, () => {
                executeGodFavor(sum);
            });
        }

        function executeGodFavor(sum) {
            const player = gameState.players[gameState.currentPlayerIndex];

            switch (sum) {
                case 2: // Ath√©na
                    player.hasAthenaShield = true;
                    showNotification(`${player.name} a le bouclier d'Ath√©na !`);
                    nextPlayer();
                    break;
                case 3: // Aphrodite
                    showPlayerSelector(2, (selectedPlayers) => {
                        selectedPlayers.forEach(p => {
                            const move = Math.floor(Math.random() * 6) + 1;
                            p.position += Math.random() > 0.5 ? move : -move;
                            if (p.position < 0) p.position = 0;
                            if (p.position >= BOARD_SIZE) p.position = BOARD_SIZE - 1;
                        });
                        drawBoard();
                        nextPlayer();
                    }, false);
                    break;
                case 4: // Herm√®s
                    showPlayerSelector(1, (selectedPlayers) => {
                        const temp = player.position;
                        player.position = selectedPlayers[0].position;
                        selectedPlayers[0].position = temp;
                        drawBoard();
                        nextPlayer();
                    }, false);
                    break;
                case 5: // Apollon
                    showNotification(`${player.name} rejoue !`);
                    setTimeout(() => {
                        gameState.currentPlayerIndex = (gameState.currentPlayerIndex - 1 + gameState.players.length) % gameState.players.length;
                        nextPlayer();
                    }, 1500);
                    break;
                case 6: // Ar√®s
                    showNotification(`Tous les joueurs : pouce haut ou bas !`);
                    setTimeout(() => nextPlayer(), 2000);
                    break;
                case 7: // Dionysos
                    gameState.players.forEach(p => p.drinks += 2);
                    showNotification(`Tous boivent avec ${player.name} !`);
                    setTimeout(() => nextPlayer(), 2000);
                    break;
                case 8: // H√©pha√Østos
                    showNotification(`${player.name} place 2 shooters virtuels !`);
                    setTimeout(() => nextPlayer(), 2000);
                    break;
                case 9: // Pos√©idon
                    showPlayerSelector(1, (selectedPlayers) => {
                        selectedPlayers[0].drinks += 3;
                        showNotification(`${selectedPlayers[0].name} boit 3 gorg√©es !`);
                        nextPlayer();
                    }, false);
                    break;
                case 10:
                case 11: // Jugement Dernier
                    const newRoll = Math.floor(Math.random() * 6) + 1;
                    showNotification(`Nouveau r√©sultat : ${newRoll}`);
                    setTimeout(() => {
                        applyGodFavor(newRoll + Math.floor(Math.random() * 6) + 1);
                    }, 1500);
                    break;
                case 12: // Col√®re
                    player.drinks += 3;
                    showNotification(`${player.name} boit 3 gorg√©es !`);
                    setTimeout(() => nextPlayer(), 2000);
                    break;
                default:
                    nextPlayer();
            }
        }

        function applySpecificEffect(type) {
            switch (type) {
                case TILE_TYPES.DRINK_2:
                case TILE_TYPES.DRINK_3:
                case TILE_TYPES.DRINK_4:
                    handleDrinkEffect(type);
                    break;
                case TILE_TYPES.DISTRIBUTE_2:
                case TILE_TYPES.DISTRIBUTE_3:
                case TILE_TYPES.DISTRIBUTE_4:
                    handleDistributeEffect(type);
                    break;
                default:
                    nextPlayer();
            }
        }

        function showEffect(icon, title, description, callback) {
            document.getElementById('effectIcon').textContent = icon;
            document.getElementById('effectTitle').textContent = title;
            document.getElementById('effectDescription').textContent = description;
            document.getElementById('effectInteraction').innerHTML = '';

            document.getElementById('effectModal').classList.add('show');

            // Show OK button by default
            document.getElementById('effectOkBtn').style.display = 'block';

            // Store the callback
            const okBtn = document.getElementById('effectOkBtn');
            okBtn.onclick = () => {
                closeEffectModal();
                if (callback) {
                    callback();
                }
            };
        }

        function showPlayerSelector(count, callback, allowSelf = true) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const availablePlayers = allowSelf ? gameState.players : gameState.players.filter(p => p !== player);

            console.log('showPlayerSelector - count:', count, 'allowSelf:', allowSelf);

            const container = document.getElementById('effectInteraction');
            container.innerHTML = `
                <p style="margin-bottom: 15px;"><strong>S√©lectionnez ${count} joueur(s) :</strong></p>
                <div class="player-selector" id="playerSelector"></div>
            `;

            const selector = document.getElementById('playerSelector');
            const selected = [];

            availablePlayers.forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-selector-item';
                div.innerHTML = `
                    <div style="font-weight: bold;">${p.name}</div>
                    <div style="font-size: 0.85em; opacity: 0.8;">üç∫ ${p.drinks} gorg√©es</div>
                `;
                div.style.borderColor = p.color;
                div.style.borderWidth = '3px';

                div.onclick = () => {
                    if (selected.includes(p)) {
                        selected.splice(selected.indexOf(p), 1);
                        div.classList.remove('selected');
                    } else if (selected.length < count) {
                        selected.push(p);
                        div.classList.add('selected');
                    } else {
                        // Deselect first and select new
                        const oldSelection = selector.querySelector('.selected');
                        if (oldSelection) {
                            oldSelection.classList.remove('selected');
                        }
                        selected[0] = p;
                        div.classList.add('selected');
                    }

                    if (selected.length === count) {
                        console.log('Selection complete, calling callback');
                        setTimeout(() => {
                            closeEffectModal();
                            callback(selected);
                        }, 300);
                    }
                };

                selector.appendChild(div);
            });

            // Disable OK button until selection is made
            document.getElementById('effectOkBtn').style.display = 'none';
        }

        function showRuleInput(callback) {
            const container = document.getElementById('effectInteraction');
            container.innerHTML = `
                <div class="input-group">
                    <label>Entrez votre r√®gle personnalis√©e :</label>
                    <textarea id="ruleInput" placeholder="Ex: Chaque gorg√©e compte double !"></textarea>
                </div>
            `;

            document.getElementById('effectOkBtn').onclick = () => {
                const rule = document.getElementById('ruleInput').value.trim();
                if (rule) {
                    closeEffectModal();
                    callback(rule);
                } else {
                    alert('Veuillez entrer une r√®gle !');
                }
            };
        }

        function closeEffectModal() {
            document.getElementById('effectModal').classList.remove('show');

            // Reset OK button visibility
            document.getElementById('effectOkBtn').style.display = 'block';

            // Make sure to clear the blocking state
            gameState.waitingForEffect = false;

            // Re-enable dice button just in case
            document.getElementById('rollDiceBtn').disabled = false;
        }

        function nextPlayer() {
            console.log('nextPlayer called');

            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            updatePlayerList();

            // FORCE reset all blocking states
            gameState.isRolling = false;
            gameState.waitingForEffect = false;

            // FORCE re-enable the dice button
            const diceBtn = document.getElementById('rollDiceBtn');
            diceBtn.disabled = false;

            console.log('Next player ready - isRolling:', gameState.isRolling, 'waitingForEffect:', gameState.waitingForEffect, 'button disabled:', diceBtn.disabled);

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            showNotification(`Au tour de ${currentPlayer.name} !`);
        }

        function updatePlayerList() {
            const list = document.getElementById('playerList');
            list.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `player-item ${index === gameState.currentPlayerIndex ? 'active' : ''}`;
                div.innerHTML = `
                    <span class="player-name">${player.name}</span>
                    <span class="player-info">Case ${player.position} | üç∫ ${player.drinks}${player.hasSchmittPower ? ' üëë' : ''}</span>
                `;
                div.style.borderLeft = `4px solid ${player.color}`;
                list.appendChild(div);
            });
        }

        function showNotification(message) {
            const notif = document.getElementById('notification');
            notif.textContent = message;
            notif.classList.add('show');

            setTimeout(() => {
                notif.classList.remove('show');
            }, 2000);
        }

        init();
    </script>
</body>

</html>
